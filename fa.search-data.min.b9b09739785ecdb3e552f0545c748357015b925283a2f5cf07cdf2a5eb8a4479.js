'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/fa/docs/01-what-why-and-how/','title':"چه چیزی، چرا و چگونه",'section':"Docs",'content':"WebRTC چیست؟ #  WebRTC، که اختصاری برای Web Real-Time Communication می باشد، هم یک API و هم یک پروتکل است. پروتکل WebRTC مجموعه ای از قوانین برای دو نماینده WebRTC برای مذاکره دو طرفه و ایمن در زمان بی درنگ است. WebRTC API نیز به توسعه دهنگان اجازه می دهد که از پروتکل WebRTC استفاده کنند. WebRTC API فقط برای زبان جاوا اسکریپت است.\nیک رابطه مشابه بین HTTP و Fetch API وجود دارد. پروتکل WebRTC همانند HTTP و WebRTC API مانند Fetch API است.\nپرونکل WebRTC در API ها و زبان های دیگر علاوه بر جاوا اسکریپت وجود دارد. شما می توانید سرورها و همچنین ابزار های domain-specific را پیدا کنید. همه ی این پیاده سازی ها از پروتکل WebRTC استفاده می کنند بنابراین آن ها می توانند با یکدیگر تعامل داشته باشند.\nپروتکل WebRTC در IETF و در گروه کاری rtcweb نگهداری می شود. WebRTC API نیز در W3C تحت عنوان webrtc مستند سازی شده است.\nچرا باید WebRTC را یاد بگیرم؟ #  این های چیز هایی هستند که WebRTC به شما خواهد داد. این لیست جامع نیست، فقط یک نمونه از چیز هایست که ممکن است در خلال سفر یادگیریتان قدردان آن شوید. اگر تمامی این مباحث را نمی دانید نگران نباشید، این کتاب این ها را در مسیر یادگیری به شما آموزش خواهد داد.\n یک استاندارد باز چندین پیاده سازی دسترسی در مرورگر ها رمزنگاری اجباری پیمایش NAT فناوری موجود تغییر کاربری داده شده کنترل ازدحام تاخیری کمتر از یک ثانیه  پروتکل WebRTC یک مجموعه از دیگر فناوری هاست #  این یک عنوان است که به اندازه یک کتاب کامل برای توضیح دادنش وقت می برد. هرچند برای شروع ما این را به چهار بخش تقسیم کرده ایم.\n سیگنالینگ اتصال امنیت برقرای ارتباط  این چهار گام به ترتیب اجرا می شوند. برای شروع گام بعدی، باید گام قبلی به صورت 100% موفقیت آمیز بوده باشد.\nیک حقیقت عجیب و غریب درباره WebRTC این است که هر گام در حقیقت از چندین پروتکل دیگر ساخته شده است! برای ساخت WebRTC ما خیلی از فناوری های دیگر را با هم پیوند زده ایم. از این رو، WebRTC بیشتر یک ترکیب و پیکربندی از فناوری های به خوبی درک شده است که از اویل دهه ی 2000 دور ما بوده است.\nهر یک از این گام ها یک بخش مختص به خود دارند، اما بسیار مفید است که اول آن ها را در سطح بالاتر درک کنیم. به دلیل این که آن ها به یکدیگر وابسه هستند، این به شما کمک خواهد کرد که وقتی توضیح بیشتری درباره اهداف هر کدام از این گام ها به شما می دهیم درک بهتری داشته باشید.\nسیگنالینگ: چگونه همتا ها(رایانه ها) همدیگر را در WebRTC پیدا می کنند #  زمانی که یک نماینده WebRTC می خواهد شروع می کند، هیچ ایده ای ندارد که با چه کسی قرار است برقراری ارتباط را انجام دهد و با چه چیزی قرار است با آن ها در ارتباط باشد. سیگنالیگ این مسئله را حل کرده است! سیگنالیگ استفاده می شود که تماس را راه‌اندازی کند. بنابراین دو نماینده WebRTC می توانند ارتباط را آغاز کنند.\nسگتالینگ از یک پروتکل موجود به نام SDP (پروتکل توضیح نشست) استفاده می کند. SDP یک پروتکل متن ساده است. هر پیغام SDP از جفت های کلید/مقدار ساخته شده است و شامل یک لیست از \u0026ldquo;بخش های رسانه\u0026rdquo; است. SDP ی جزییات تبادل دو نماینده WebRTC مانند زیر است\n آی پی ها و درگاه های که به داوطلب ها، قابل دسترسی است. چه تعداد ویدیو و صدا نماینده می خواهد بفرستد. چه کدک ویدیو و صدا هر نماینده پشتیبانی می کند. مقادیری که بین اتصال استفاده می شود (uFrag/uPwd). مقادیری امنیتی (اثر انگشت گواهینامه امنیتی).  توجه داشته باشید که سیگنالینگ معمولا وقتی \u0026ldquo;خارج از دسترس است\u0026rdquo; اتفاق می افتد؛ که به این معناست که، برنامه ها غالبا از خود WebRTC برای تبادل پیغام های WebRTC استفاده نمی کنند. از هر معماری مناسب برای ارسال پیام می توان برای انتقال SDP ها بین همتاهای متصل استفاده کرد و بسیاری از برنامه ها از زیرساخت موجود خود (مانند نقاط پایانی REST، اتصالات WebSocket یا پراکسی های احراز هویت) برای تسهیل تبادل آسان SDP ها بین کاربران استفاده می کنند.\nاتصالات و پیمایش NAT با استفاده از STUN/TURN #  دو نماینده WebRTC اکنون جزئیات کافی برای اتصال به یکدیگر را می دانند. سپس WebRTC از یک فناوری دیگر به نام ICE استفاده می کند.\nICE (Interactive Connectivity Establishment) پروتکلی است که قدمت آن قبل از WebRTC است. ICE امکان برقراری ارتباط بین دو عامل را فراهم می کند. این عوامل می توانند در همان شبکه یا در آن سوی دنیا باشند. ICE راه حلی برای برقراری ارتباط مستقیم بدون سرور مرکزی است.\nجادوی واقعی اینجا \u0026lsquo;NAT Traversal\u0026rsquo; و STUN/TURN سرور است. این دو مفهوم تنها چیزی است که برای برقراری ارتباط با یک عامل ICE در زیرشبکه دیگر نیاز دارید. ما بعداً به بررسی عمیق این موضوعات خواهیم پرداخت.\nهنگامی که ICE با موفقیت وصل شد، WebRTC سپس به ایجاد یک انتقال رمزگذاری شده می‌پردازد. این انتقال برای صدا، تصویر و داده استفاده می شود.\nایمن سازی لایه انتقال با DTLS و SRTP #  اکنون که ارتباط دو طرفه داریم (از طریق ICE) باید ارتباط امن برقرار کنیم. این کار از طریق دو پروتکل انجام می شود که قدمتی بیش از WebRTC دارند. اولین پروتکل DTLS (امنیت لایه انتقال داده) است که فقط TLS روی UDP است. TLS پروتکل رمزنگاری است که برای ایمن سازی ارتباطات از طریق HTTPS استفاده می شود. پروتکل دوم SRTP (پروتکل امن حمل و نقل بلادرنگ) است.\nابتدا WebRTC با انجام یک دست دادن(Hand Shaking) DTLS روی اتصال ایجاد شده توسط ICE متصل می شود. برخلاف HTTPS، WebRTC از مرجع مرکزی برای گواهی ها استفاده نمی کند. در عوض، WebRTC فقط ادعا می کند که گواهی مبادله شده از طریق DTLS با اثر انگشت به اشتراک گذاشته شده از طریق سیگنالینگ مطابقت دارد. این اتصال DTLS سپس برای پیام های DataChannel استفاده می شود.\nسپس WebRTC از پروتکل دیگری برای انتقال صدا/تصویر به نام RTP استفاده می کند. ما بسته های RTP خود را با استفاده از SRTP ایمن می کنیم. ما جلسه SRTP خود را با استخراج کلیدها از جلسه DTLS مذاکره شده اولیه ایمن می کنیم. در فصل بعدی، به این بحث خواهیم پرداخت که چرا انتقال رسانه، پروتکل خاص خود را دارد.\nحالا کار ما تمام شد! اکنون ارتباط دو طرفه و ایمن دارید. اگر یک ارتباط پایدار بین نمایندگان WebRTC خود دارید، به این همه پیچیدگی ممکن است نیاز داشته باشید. متأسفانه، دنیای واقعی محدودیت‌هایی برای از دست دادن بسته‌ها و پهنای باند دارد و بخش بعدی درباره نحوه برخورد ما با آن‌ها است.\nارتباط با همتایان از طریق RTP و SCTP #  ما اکنون دو نماینده WebRTC با ارتباطات دوطرفه ایمن داریم. بیایید ارتباط را شروع کنیم! مجدداً از دو پروتکل از قبل موجود استفاده می کنیم: RTP (پروتکل حمل و نقل بلادرنگ) و SCTP (پروتکل انتقال کنترل جریان). از RTP برای تبادل رسانه های رمزگذاری شده با SRTP و از SCTP برای ارسال و دریافت پیام های DataChannel رمزگذاری شده با DTLS استفاده می کنیم.\nRTP بسیار کوچک است اما آنچه را که برای پیاده‌سازی جریان بلادرنگ نیاز است را فراهم می کند. نکته مهم این است که RTP به توسعه‌دهنده انعطاف‌پذیری می‌دهد، بنابراین آنها می‌توانند تاخیر، از دست دادن و تراکم داده را به دلخواه خود مدیریت کنند. در بخش رسانه بیشتر به این موضوع خواهیم پرداخت.\nپروتکل نهایی در این بخش SCTP است. SCTP اجازه می دهد گزینه های بسیاری برای تحویل پیام ها داشته باشیم. شما می توانید به صورت اختیاری انتخاب کنید که تحویل غیرقابل اعتماد و خارج از سفارش داشته باشید، بنابراین می توانید تاخیر مورد نیاز برای سیستم های بلادرنگ را دریافت کنید.\nWebRTC، مجموعه ای از پروتکل ها #  WebRTC بسیاری از مشکلات را حل می کند. در ابتدا، این ممکن است حتی بیش از حد مهندسی شده به نظر برسد. نبوغ WebRTC واقعاً وصف نکردنی است. در ابتدا تصور نمی شد که بتواند همه چیز را بهتر حل کند. در عوض، بسیاری از فن‌آوری‌های تک منظوره موجود را در بر گرفت و آنها را با هم ترکیب کرد.\nاین به ما این امکان را می دهد که هر قسمت را به صورت جداگانه بررسی و یاد بگیریم بدون اینکه در آنغرق شویم. یک راه خوب برای یادگیری آن این است که \u0026ldquo;WebRTC Agent\u0026rdquo; را در واقع مثل یک ارکستراتور پروتکل های مختلف تجسم کنیم.\nWebRTC (API) چگونه کار می کند #  این بخش نشان می دهد که چگونه API جاوا اسکریپت به پروتکل نگاشت می شود. این یک نسخه نمایشی گسترده از WebRTC API نیست، بلکه بیشتر برای ایجاد یک مدل ذهنی از نحوه پیوند آن با یکدیگر است. اگر با هیچکدام آشنا نیستید، اشکالی ندارد. این می تواند یک بخش سرگرم‌کننده برای یادگیری بیشتر برای شما باشد!\nnew RTCPeerConnection #  RTCPeerConnection سطح بالای \u0026ldquo;نشست WebRTC\u0026rdquo; است. این شامل تمام پروتکل های ذکر شده در بالا است. زیرسیستم ها همه تخصیص داده شده اند اما هنوز هیچ اتفاقی نمی افتد.\naddTrack #  addTrack یک جریان RTP جدید ایجاد می کند. یک منبع همگام سازی تصادفی (SSRC) برای این جریان ایجاد می شود. سپس این جریان در قسمت توضیحات جلسه ایجاد شده توسط createOffer در یک بخش رسانه قرار خواهد گرفت. هر تماس با addTrack یک بخش رسانه و SSRC جدید ایجاد می کند.\nبلافاصله پس از ایجاد یک جلسه SRTP، این بسته های رسانه ای پس از رمزگذاری با استفاده از SRTP از طریق ICE ارسال می شوند.\ncreateDataChannel #  createDataChannel در صورت عدم وجود ارتباط SCTP، یک جریان SCTP جدید ایجاد می کند. به طور پیش‌فرض، SCTP فعال نیست، اما تنها زمانی شروع می‌شود که یک طرف درخواست کانال داده را داشته باشد.\nبلافاصله پس از ایجاد یک جلسه DTLS، انجمن SCTP شروع به ارسال بسته ها از طریق ICE و رمزگذاری شده با DTLS می کند.\ncreateOffer #  createOffer یک Session Description از وضعیت محلی ایجاد می کند تا با همتای راه دور به اشتراک گذاشته شود.\nعمل فراخوانی createOffer چیزی را برای همتای محلی تغییر نمی‌دهد.\nsetLocalDescription #  setLocalDescription هر گونه تغییر درخواستی را انجام می دهد. addTrack، createDataChannel و تماس‌های مشابه همگی تا برقراری این تماس، به تعویق می افتد. setLocalDescription با مقدار ایجاد شده توسط createOffer فراخوانی می شود.\nمعمولاً پس از این تماس، پیشنهاد را برای همتای راه دور ارسال می‌کنید و آنها با آن setRemoteDescription را فراخوانی می‌کنند.\nsetRemoteDescription #  setRemoteDescription نحوه اطلاع رسانی به نماینده محلی در مورد وضعیت داوطلب ها راه دور است. به این ترتیب عمل \u0026lsquo;سیگنالینگ\u0026rsquo; با API جاوا اسکریپت انجام می شود.\nوقتی setRemoteDescription از هر دو طرف فراخوانی شد، نمایندگان WebRTC اکنون اطلاعات کافی برای شروع ارتباط Peer-To-Peer (P2P) را دارند!\naddIceCandidate #  addIceCandidate به یک نماینده WebRTC اجازه می‌دهد تا هر زمان که بخواهد، نامزدهای ICE راه دور بیشتری را اضافه کند. این ICE Candidate ،API را مستقیماً به زیرسیستم ICE می فرستد و تأثیر بیشتر دیگری بر اتصال WebRTC ندارد.\nontrack #  ontrack یک تابع بازگشتی است که زمانی که بسته RTP از همتای راه دور دریافت می‌شود، فعال می‌شود. بسته‌های دریافتی باید در توضیحات جلسه که به setRemoteDescription ارسال شده بود، تعیین شده باشند.\nWebRTC از SSRC استفاده می‌کند و توابع بازگشتی MediaStream و MediaStreamTrack مرتبط این جزئیات فراخوانی می‌کند.\noniceconnectionstatechange #  oniceconnectionstatechange یک تابع بازگشتی است که وضعیت عامل ICE را فراخوانی می‌کند. هنگامی که شما به شبکه متصل هستید یا زمانی که اتصال شما قطع می شود به این ترتیب به شما اطلاع داده می شود.\nonconnectionstatechange #  onconnectionstatechange ترکیبی از ICE Agent و وضعیت عامل DTLS است. این می‌تواند شما را زمانی که ICE و DTLS هر دو با موفقیت تکمیل شدند مطلع کند.\n"});index.add({'id':1,'href':'/fa/docs/02-signaling/','title':"سیگنالینگ",'section':"Docs",'content':"سیگنالینگ WebRTC چیست؟ #  هنگامی که یک عامل WebRTC ایجاد می کنید، چیزی در مورد همتای دیگر نمی داند. هیچ ایده ای ندارد که قرار است با چه کسی ارتباط برقرار کند یا قرار است چه چیزی بفرستد! سیگنالینگ راه‌اندازی اولیه است که تماس را ممکن می‌سازد. پس از رد و بدل شدن این مقادیر، عوامل WebRTC می توانند مستقیماً با یکدیگر ارتباط برقرار کنند.\nپیام های سیگنالینگ فقط متن هستند. عوامل WebRTC اهمیتی نمی دهند که چگونه پیام ها منتقل می شوند. آنها معمولاً از طریق سوکت های وب به اشتراک گذاشته می شوند، اما همیشه اینگونه نیست.\nسیگنالینگ WebRTC چگونه کار می کند؟ #  WebRTC از یک پروتکل موجود به نام Session Description Protocol استفاده می کند. از طریق این پروتکل، دو عامل WebRTC تمام وضعیت مورد نیاز برای ایجاد یک اتصال را به اشتراک خواهند گذاشت. خود پروتکل برای خواندن و درک ساده است. پیچیدگی این عمل از فهمیدن مقادیری است که توسط WebRTC پر می شود.\nاین پروتکل مختص WebRTC نیست. ابتدا پروتکل توضیحات جلسه را بدون حتی صحبت در مورد WebRTC یاد خواهیم گرفت. WebRTC از زیرمجموعه ای از پروتکل بهره می برد، بنابراین ما فقط می خواهیم آنچه را که نیاز داریم پوشش دهیم. پس از درک پروتکل، ما نمونه استفاده شده در WebRTC را بررسی می کنیم.\nپروتکل Session Description Protocol (SDP) چیست؟ #  پروتکل شرح جلسه در RFC 8866 معرفی شده است. این یک پروتکل کلید / مقدار با یک خط جدید پس از هر مقدار است. این همانند یک فایل INI خواهد بود. شرح جلسه، حاوی هیچ یا بیشتر از یک توضیحات رسانه است. از نظر ذهنی می‌توانید آن را به‌عنوان شرح جلسه که حاوی مجموعه‌ای از توضیحات رسانه است، مدل‌سازی کنید.\nتوصیف رسانه معمولاً به یک جریان رسانه منفرد نگاشت می شود. بنابراین اگر می‌خواهید تماسی را با سه جریان ویدیویی و دو آهنگ صوتی توصیف کنید، باید پنج توضیح رسانه داشته باشید.\nنحوه خواندن SDP #  هر خط در توضیحات جلسه با یک کاراکتر شروع می شود، این کلید شماست. سپس علامت مساوی به دنبال آن خواهد آمد. همه چیز بعد از آن علامت مساوی، مقدار است. پس از تکمیل مقدار، یک خط جدید خواهید داشت.\nپروتکل Session Description تمام کلیدهای معتبر را تعریف می کند. شما فقط می توانید از حروف برای کلیدها همانطور که در پروتکل تعریف شده است استفاده کنید. این کلیدها همگی معنی قابل توجهی دارند که بعدا توضیح داده خواهد شد.\nاین گزیده توضیحات جلسه را در نظر بگیرید:\na=my-sdp-value a=second-value شما دو خط دارید. هر کدام با کلید a. خط اول دارای مقدار my-sdp-value است، خط دوم دارای مقدار second-value است.\nWebRTC فقط از برخی کلیدهای SDP استفاده می کند #  تمام مقادیر کلیدی تعریف شده توسط پروتکل شرح جلسه توسط WebRTC استفاده نمی شود. فقط کلیدهای مورد استفاده در پروتکل ایجاد جلسه جاوا اسکریپت (JSEP) که در RFC 8829 تعریف شده است، مهم هستند. هفت کلید زیر تنها کلیدهایی هستند که در حال حاضر باید بدانید:\n v - نسخه، باید برابر با 0 باشد. o - مبدا، حاوی شناسه منحصر به فردی است که برای مذاکره مجدد مفید است. s - نام جلسه، باید برابر با - باشد. t - زمان بندی، باید برابر با 0 0 باشد. m - توضیحات رسانه ( m = \u0026lt;media\u0026gt; \u0026lt;port\u0026gt; \u0026lt;proto\u0026gt; \u0026lt;fmt\u0026gt; ...)، به تفصیل در زیر توضیح داده شده است. a - ویژگی ها، یک فیلد متن آزاد. این رایج ترین خط در WebRTC است. c - داده های اتصال، باید برابر با` IN IP4 0.0.0.0 باشد.  توضیحات رسانه در شرح جلسه #  شرح جلسه می تواند شامل تعداد نامحدودی از توضیحات رسانه باشد.\nتعریف توصیف رسانه حاوی لیستی از قالب ها است. این قالب‌ها به انواع RTP Payload نگاشت می‌شوند. سپس کدک واقعی توسط یک ویژگی با مقدار rtpmap در توضیحات رسانه تعریف می شود. اهمیت انواع RTP و RTP Payload بعداً در فصل رسانه مورد بحث قرار می گیرد. هر توصیف رسانه می تواند شامل تعداد نامحدودی از ویژگی ها باشد.\nاین گزیده توضیحات جلسه را به عنوان مثال در نظر بگیرید:\nv=0 m=audio 4000 RTP/AVP 111 a=rtpmap:111 OPUS/48000/2 m=video 4000 RTP/AVP 96 a=rtpmap:96 VP8/90000 a=my-sdp-value شما دو توصیف رسانه دارید، یکی از نوع صوتی با فرمت 111 و یکی از نوع ویدیویی با فرمت 96. اولین توصیف رسانه ای تنها یک ویژگی دارد. این ویژگی نوع Payload \u0026lsquo;111\u0026rsquo; را به Opus ترسیم می کند. شرح رسانه دوم دو ویژگی دارد. ویژگی اول، نوع Payload ا96 را به عنوان VP8 ترسیم می کند، و ویژگی دوم فقط my-sdp-value است.\nمثال کامل #  در ادامه تمام مفاهیمی که در مورد آنها صحبت کرده ایم را گرد هم آورده است. اینها همه ویژگی های پروتکل شرح جلسه است که WebRTC از آن استفاده می کند. اگر می توانید این را بخوانید، می توانید هر شرح جلسه WebRTC را بخوانید!\nv=0 o=- 0 0 IN IP4 127.0.0.1 s=- c=IN IP4 127.0.0.1 t=0 0 m=audio 4000 RTP/AVP 111 a=rtpmap:111 OPUS/48000/2 m=video 4002 RTP/AVP 96 a=rtpmap:96 VP8/90000  کلیدهای v, o, s, c, t تعریف شده اند، اما بر جلسه WebRTC تأثیری ندارند. دو شرح رسانه ای دارید. یکی از نوع صوتی و یکی از نوع ویدئو. هر کدام از آن ها یک ویژگی دارند. این ویژگی جزئیات پایپ لاین RTP را که در فصل ارتباطات رسانه ای مورد بحث قرار گرفته است، پیکربندی می کند.  چگونه پروتکل شرح جلسه و WebRTC با هم کار می کنند #  بخش بعدی این پازل درک این که چگونه WebRTC از پروتکل شرح جلسه استفاده می کند می باشد.\nپیشنهاداتOffers و پاسخ هاAnswers چیست؟ #  WebRTC از مدل پیشنهاد/پاسخ استفاده می کند. همه اینها به این معنی است که یک نماینده WebRTC یک پیشنهاد برای شروع یک تماس ارائه می دهد، و سایر نمایندگان WebRTC در صورتی که مایل به پذیرش آنچه ارائه شده است پاسخ می دهند.\nاین به پاسخ دهنده فرصتی می دهد تا کدک های پشتیبانی نشده در توضیحات رسانه را رد کند. به این ترتیب دو همتا می توانند بفهمند که مایل به تبادل چه قالب هایی هستند.\nمفهوم Transceivers برای ارسال و دریافت است #  واژه Transceivers یک مفهوم خاص WebRTC است که در API خواهید دید. کاری که انجام می دهد این است که توضیحات رسانه را در API جاوا اسکریپت قرار می دهد. هر توصیف رسانه ای تبدیل به یک Transceiver می شود. هر بار که یک Transceiver ایجاد می کنید، یک توضیح رسانه جدید به توضیحات جلسه محلی اضافه می شود.\nهر توضیح رسانه در WebRTC یک ویژگی direction دارد. این به یک نماینده WebRTC اجازه می دهد تا اعلام کند \u0026ldquo;من قصد دارم این کدک را برای شما ارسال کنم، اما حاضر نیستم چیزی را پس بگیرم\u0026rdquo;. چهار مقدار معتبر وجود دارد:\n send recv sendrecv inactive  مقادیر SDP استفاده شده توسط WebRTC #  این لیستی از برخی ویژگی های رایج است که در توضیحات جلسه از یک عامل WebRTC مشاهده خواهید کرد. بسیاری از این مقادیر، زیرسیستم هایی را کنترل می کنند که ما هنوز در مورد آنها صحبت نکرده ایم.\ngroup:BUNDLE #  باندلینگ عملی است برای اجرای چندین نوع ترافیک روی یک اتصال. برخی از پیاده سازی های WebRTC از یک اتصال اختصاصی از طریق جریان رسانه استفاده می کنند که باندلینگ باید در اولویت باشد.\nfingerprint:sha-256 #  این هش گواهی است که یک همتا برای DTLS استفاده می کند. پس از تکمیل دست دادن DTLS، آن را با گواهی واقعی مقایسه می کند تا تأیید کند که با کسی که انتظار دارید در ارتباط هستید.\nsetup: #  این رفتار عامل DTLS را کنترل می کند. این مشخص می کند که آیا پس از اتصال، ICE به عنوان مشتری یا سرور اجرا می شود. مقادیر ممکن عبارتند از:\n setup:active - به عنوان سرویس گیرنده DTLS اجرا شود. setup:passive - به عنوان سرور DTLS اجرا شود. setup: actpass - از دیگر نماینده WebRTC بخواهد انتخاب کند.  ice-ufrag #  این مقدار قطعه کاربر برای عامل ICE است. برای احراز هویت ترافیک ICE استفاده می شود.\nice-pwd #  این رمز عبور عامل ICE است. برای احراز هویت ترافیک ICE استفاده می شود.\nrtpmap #  این مقدار برای نگاشت یک کدک خاص به نوع RTP Payload استفاده می شود. انواع بار(Payload) ثابت نیستند، بنابراین برای هر تماس پیشنهاد دهنده انواع بار(Payload) برای هر کدک را تعیین می کند.\nfmtp #  مقادیر اضافی را برای یک نوع محموله تعریف می کند. این برای برقراری ارتباط با یک نمایه ویدیویی خاص یا تنظیمات رمزگذار مفید است.\ncandidate #  این یک نامزد ICE است که از عامل ICE می آید. این یکی از آدرس‌های احتمالی است که WebRTC Agent در آن موجود است. این موارد در فصل بعدی به طور کامل توضیح داده می شود.\nsrc #  منبع همگام سازی (SSRC) یک مسیر جریان رسانه واحد را تعریف می کند.\nlabel شناسه این جریان فردی است. mslabel شناسه کانتینری است که می‌تواند چندین جریان درون آن داشته باشد.\nمثالی از توضیحات جلسه WebRTC #  در زیر شرح کامل جلسه(SDP) ایجاد شده توسط یک کلاینت WebRTC است:\nv=0 o=- 3546004397921447048 1596742744 IN IP4 0.0.0.0 s=- t=0 0 a=fingerprint:sha-256 0F:74:31:25:CB:A2:13:EC:28:6F:6D:2C:61:FF:5D:C2:BC:B9:DB:3D:98:14:8D:1A:BB:EA:33:0C:A4:60:A8:8E a=group:BUNDLE 0 1 m=audio 9 UDP/TLS/RTP/SAVPF 111 c=IN IP4 0.0.0.0 a=setup:active a=mid:0 a=ice-ufrag:CsxzEWmoKpJyscFj a=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd a=rtcp-mux a=rtcp-rsize a=rtpmap:111 opus/48000/2 a=fmtp:111 minptime=10;useinbandfec=1 a=ssrc:350842737 cname:yvKPspsHcYcwGFTw a=ssrc:350842737 msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV a=ssrc:350842737 mslabel:yvKPspsHcYcwGFTw a=ssrc:350842737 label:DfQnKjQQuwceLFdV a=msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV a=sendrecv a=candidate:foundation 1 udp 2130706431 192.168.1.1 53165 typ host generation 0 a=candidate:foundation 2 udp 2130706431 192.168.1.1 53165 typ host generation 0 a=candidate:foundation 1 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0 a=candidate:foundation 2 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0 a=end-of-candidates m=video 9 UDP/TLS/RTP/SAVPF 96 c=IN IP4 0.0.0.0 a=setup:active a=mid:1 a=ice-ufrag:CsxzEWmoKpJyscFj a=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd a=rtcp-mux a=rtcp-rsize a=rtpmap:96 VP8/90000 a=ssrc:2180035812 cname:XHbOTNRFnLtesHwJ a=ssrc:2180035812 msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW a=ssrc:2180035812 mslabel:XHbOTNRFnLtesHwJ a=ssrc:2180035812 label:JgtwEhBWNEiOnhuW a=msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW a=sendrecv این چیزی است که ما از این پیام می دانیم:\n دو بخش رسانه داریم، یکی صوتی و دیگری تصویری. هر دوی آنها فرستنده گیرنده(Transceiver) sendrecv هستند. ما در حال دریافت دو جریان هستیم و می توانیم دو جریان را بفرستیم. ما جزئیات ICE Candidates و Authentication را داریم، بنابراین می‌توانیم برای اتصال تلاش کنیم. ما یک اثر انگشت گواهی داریم، بنابراین می توانیم تماس ایمن داشته باشیم.  موضوعات بیشتر #  در نسخه های بعدی این کتاب، به موضوعات زیر نیز پرداخته خواهد شد:\n مذاکره مجدد (Renegotiation) پخش همزمان (Simulcast)  "});index.add({'id':2,'href':'/fa/docs/03-connecting/','title':"اتصال",'section':"Docs",'content':"TODO\n"});index.add({'id':3,'href':'/fa/docs/04-securing/','title':"امنیت",'section':"Docs",'content':"TODO\n"});index.add({'id':4,'href':'/fa/docs/05-real-time-networking/','title':"شبکه بی درنگ",'section':"Docs",'content':"TODO\n"});index.add({'id':5,'href':'/fa/docs/06-media-communication/','title':"ارتباط رسانه ای",'section':"Docs",'content':"TODO\n"});index.add({'id':6,'href':'/fa/docs/07-data-communication/','title':"ارتباط داده ای",'section':"Docs",'content':"TODO\n"});index.add({'id':7,'href':'/fa/docs/08-applied-webrtc/','title':"اعمال کردن WebRTC",'section':"Docs",'content':"TODO\n"});index.add({'id':8,'href':'/fa/docs/09-debugging/','title':"اشکال زدایی",'section':"Docs",'content':"TODO\n"});index.add({'id':9,'href':'/fa/docs/11-faq/','title':"پرسش و پاسخ",'section':"Docs",'content':"TODO\n"});index.add({'id':10,'href':'/fa/docs/12-glossary/','title':"واژه نامه",'section':"Docs",'content':"TODO\n"});})();